#include "virtual_shadow_map_shared.h"
#include "math/transform.hlsl"
#include "math/pack.hlsl"

StructuredBuffer<RenderingConstants> g_DrawConstants;
StructuredBuffer<Instance> g_InstanceBuffer;
StructuredBuffer<float3x4> g_TransformBuffer;
StructuredBuffer<Meshlet> g_MeshletBuffer;
StructuredBuffer<uint> g_MeshletPackBuffer;
StructuredBuffer<Vertex> g_VertexBuffer;
// We have multiple index data sets for the animations.
uint g_VertexDataIndex;

#define NUM_TRIS 64
#define NUM_VERTS 64

[NumThreads(NUM_TRIS, 1, 1)]
[OutputTopology("triangle")]
void main(uint gtid : SV_GroupThreadID, uint gid : SV_GroupID, in payload MeshPayload meshPayload,
    out indices uint3 tris[NUM_TRIS], out vertices VertexParams verts[NUM_VERTS], out primitives PrimParams prims[NUM_TRIS])
{
    const uint meshletIndex = meshPayload.meshletIndex[gid];
    const uint instanceIndex = meshPayload.instanceIndex[gid];
    Meshlet meshlet = g_MeshletBuffer[meshletIndex];
    Instance instance = g_InstanceBuffer[instanceIndex];

    uint vertexCount = meshlet.vertex_count;
    uint triangleCount = meshlet.triangle_count;

    // Set the actual number of vertices and primitives.
    SetMeshOutputCounts(vertexCount, triangleCount);

    uint dataIndex = meshlet.data_offset_idx + gtid;
    float3x4 transform = g_TransformBuffer[instance.transform_index];

    if (gtid < vertexCount)
    {
        uint vertexOffset = g_MeshletPackBuffer[dataIndex];
        uint vertexIndex = vertexOffset + instance.vertex_offset_idx[g_VertexDataIndex];
        Vertex vertex = g_VertexBuffer[vertexIndex];

        float3 worldPosition = transformPoint(vertex.getPosition(), transform);

        VertexParams vertexParams;
        vertexParams.screenPosition = mul(g_DrawConstants[0].viewProjection, float4(worldPosition, 1.0f));
        vertexParams.uv = vertex.getUV();
        vertexParams.worldPosition = worldPosition;

        verts[gtid] = vertexParams;
    }

    if (gtid < triangleCount)
    {
        uint indiceIndex = dataIndex + vertexCount;

        uint packedIndices = g_MeshletPackBuffer[indiceIndex];
        uint3 unpackedIndices = uint3(packedIndices & 0x3F, (packedIndices >> 10) & 0x3F, packedIndices >> 20);
        tris[gtid] = unpackedIndices;

        prims[gtid].packedInstancePrimitive = packVisibilityBuffer(instanceIndex, meshletIndex, gtid);
    }
}
