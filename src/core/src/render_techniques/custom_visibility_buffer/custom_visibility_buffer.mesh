#include "custom_visibility_buffer_shared.h"

#include "math/transform.hlsl"

StructuredBuffer<DrawConstants> g_DrawConstants;
StructuredBuffer<Instance> g_InstanceBuffer;
StructuredBuffer<float3x4> g_TransformBuffer;
StructuredBuffer<Meshlet> g_MeshletBuffer;
StructuredBuffer<uint> g_MeshletPackBuffer;
StructuredBuffer<Vertex> g_VertexBuffer;
// We have multiple index data sets for the animations.
uint g_VertexDataIndex;

#define NUM_TRIS 64
#define NUM_VERTS 64

groupshared VertexParams lds_vertexParams[NUM_VERTS];

[NumThreads(NUM_TRIS, 1, 1)]
[OutputTopology("triangle")]
void main(uint gtid : SV_GroupThreadID, uint gid : SV_GroupID, in payload MeshPayload meshPayload,
    out indices uint3 tris[NUM_TRIS], out vertices VertexParams verts[NUM_VERTS], out primitives PrimParams prims[NUM_TRIS])
{
    const uint meshletIndex = meshPayload.meshletIndex[gid];
    const uint instanceIndex = meshPayload.instanceIndex[gid];
    Meshlet meshlet = g_MeshletBuffer[meshletIndex];
    Instance instance = g_InstanceBuffer[instanceIndex];

    uint vertexCount = meshlet.vertex_count;
    uint triangleCount = meshlet.triangle_count;

    // Set the actual number of vertices and primitives.
    SetMeshOutputCounts(vertexCount, triangleCount);

    uint dataIndex = meshlet.data_offset_idx + gtid;
    float3x4 transform = g_TransformBuffer[instance.transform_index];

    if (gtid < vertexCount)
    {
        uint vertexOffset = g_MeshletPackBuffer[dataIndex];
        uint vertexIndex = vertexOffset + instance.vertex_offset_idx[g_VertexDataIndex];
        Vertex vertex = g_VertexBuffer[vertexIndex];

        float3 worldPosition = transformPoint(vertex.getPosition(), transform);
        float3 normal = transformNormal(vertex.getNormal(), transform);

        VertexParams vertexParams;
        vertexParams.screenPosition = mul(g_DrawConstants[0].viewProjection, float4(worldPosition, 1.0f));
        vertexParams.worldPosition = worldPosition;
        vertexParams.uv = vertex.getUV();
        vertexParams.normal = normal;

        verts[gtid] = vertexParams;
    }

    GroupMemoryBarrierWithGroupSync();

    if (gtid < triangleCount)
    {
        uint indiceIndex = dataIndex + vertexCount;

        uint packedIndices = g_MeshletPackBuffer[indiceIndex];
        uint3 unpackedIndices = uint3(packedIndices & 0x3F, (packedIndices >> 10) & 0x3F, packedIndices >> 20);
        tris[gtid] = unpackedIndices;

        VertexParams v0 = lds_vertexParams[unpackedIndices.x];
        VertexParams v1 = lds_vertexParams[unpackedIndices.y];
        VertexParams v2 = lds_vertexParams[unpackedIndices.z];

        float3 edge1 = v1.worldPosition - v0.worldPosition;
        float3 edge2 = v2.worldPosition - v0.worldPosition;
        float2 deltaUV1 = v1.uv - v0.uv;
        float2 deltaUV2 = v2.uv - v0.uv;

        float2x3 tangentBitangent = float2x3(1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f);
        float det = deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y;
        if (det != 0.0f)
        {
            float2x2 invUV = float2x2(deltaUV2.y, -deltaUV1.y, -deltaUV2.x, deltaUV1.x) / det;
            float2x3 edges = float2x3(edge1, edge2);
            float2x3 tangentBitangent = mul(invUV, edges);
        }

        prims[gtid].tangent = tangentBitangent[0];
        prims[gtid].bitangent = tangentBitangent[1];
        prims[gtid].instanceID = instanceIndex;
    }
}
